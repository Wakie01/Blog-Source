---
title: 操作系统基础
comment: true
date: 2022-01-19 18:22:48
tags:
categories:
addrlink:
---

## 1. 简单说下你对并发和并行的理解？

**并行**是指两个或者多个事件在==同一时刻==发生；

**并发**是指两个或多个事件在==同一时间间隔==发生；

并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；

## 2. 同步、异步、阻塞、非阻塞的概念

**同步**：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。

**异步**：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

**阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞。

**非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程。



## 3. 进程和线程的基本概念

**进程：** 进程是系统进行资源分配和调度的一个独立单位，是系统中的并发执行的单位。

**线程：** 线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程。



## 4. 进程与线程的区别？

1. 进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；
2. 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
3. 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
4. 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；



## 5. 为什么有了进程，还要有线程呢？

进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：

1. 进程在同一时间只能干一件事情；
2. 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。

基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。



## 6. 进程的状态转换

![img](D:\blog\source\_drafts\操作系统基础\1.png)

1. **新建态：** 对应于进程被创建时的状态，尚未进入就绪队列。

   创建一个进程需要通过两个步骤：

   - 为新进程分配所需要资源和建立必要的管理信息
   - 设置该进程为就绪态，并等待被调度执行

2. **就绪（ready）态：** 进程具备运行条件，等待系统分配处理器以便运行的状态。

   当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。

3. **运行（running）态：** 进程占有处理器正在运行的状态。

   进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

4. **阻塞（block）态：** 正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行时的状态

   此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。通常系统将处于阻塞状态的进程也排成一个队列，称该队列为阻塞队列。实际上，在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因的不同，会设置多个阻塞队列。

5. **终止态：** 指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。

   处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。

   终止一个进程需要两个步骤：

   - 先等待操作系统或相关的进程进行善后处理（如抽取信息）
   - 然后回收占用的资源并被系统删除



## 7. 进程间的通信方式有哪些？

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。

IPC 的方式通常有：

- 管道（包括无名管道和命名管道）
- 消息队列
- 信号量
- 共享存储
- Socket、Streams 等

其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。

**管道：**

1. 它是半双工的，具有固定的读端和写端；
2. 它只能用于父子进程或者兄弟进程之间的进程的通信；
3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

**命名管道**

1. FIFO 可以在无关的进程之间交换数据，与无名管道不同；
2. FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

**消息队列**

1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；
2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
3. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；
4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

**信号量**

1. 信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；
2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；
3. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；
4. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；
5. 支持信号量组。

**共享内存**

1. 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；
2. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。



## 8. 进程的调度算法有哪些？

调度算法是指：根据系统的资源分配策略所规定的资源分配算法。

常用的调度算法有：先来先服务调度算法（FCFS）、时间片轮转调度法（RR）、短作业优先调度算法（SJF）、高响应比优先调度算法（HRRF）、优先级调度算法（Priority）等等。

1. **先来先服务调度算法（FCFS）**

   先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。

   优点：

   - 简单，易于实现
   - 每个进程都有机会运行，因此不会发生饥饿

   缺点：

   - 无法选择先占进程。 如果启动了进程，则CPU将执行该进程，直到结束。
   - 因为没有抢占，所以如果长时间执行某个进程，则队列后面的进程将不得不等待很长时间才能获得执行的机会。

2. **时间片轮转调度法（Round Robin，RR）：**

   时间片轮转调度算法主要适用于分时系统。其次，它是抢占式策略。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片。

   优点：

   - CPU在固定的时间范围内为每个进程提供服务，因此所有进程都具有相同的优先级。
   - 不会发生饥饿，因为对于每个循环周期，每个进程都有固定的执行时间。

   缺点：

   - 若时间片过短，则CPU从一个进程切换到另一个进程的次数将增加， 这会导致CPU效率降低
   - 若时间片过长，则它就类似于先来先调度算法了

3. **短作业优先调度算法（SJF）：** 

   短作业优先调度算法是指对短作业优先调度的算法，从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。 短作业优先调度算法是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。

   优点：

   - 可以在更短的时间内执行更多的处理，因此提高了吞吐量。

   缺点：

   - CPU必须事先知道进程所花费的时间，这是不可能的。
   - 较长的过程将有更多等待时间，往往会出现进程饥饿。

4. **高响应比优先调度算法（HRRF）：**   

   高响应比优先调度算法，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。

   响应比计算公式：
   $$
   响应比R_p=\frac {等待时间+要求服务时间}{要求服务时间}
   $$

5. **优先级调度算法（Priority）：**

   优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

   缺点：

   - 低优先级的进程可能会出现进程饥饿

   

## 9. 什么是死锁？

死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。

![image-20210607160841587](D:\blog\source\_drafts\操作系统基础\2.png)



## 10.  产生死锁的原因？

由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。

产生死锁的原因：

1. 系统资源的竞争

   进程在对不可剥夺资源的竞争中可能会产生死锁。例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。

2. 进程推进顺序非法

   例如：进程 A 和 进程 B 互相等待对方的数据。

3. 满足死锁产生的必要条件：

   - 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用
   - 不可剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
   - 请求并保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
   - 循环等待条件：在发生死锁时，必然存在一个进程–资源的环形链

> **系统中的资源可以分为两类：**
>
> 1. 可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源；
> 2. 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。



## 11. 死锁产生的必要条件？

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 循环等待条件：在发生死锁时，必然存在一个进程–资源的环形链。



## 12. 解决死锁的基本方法？

1. **预防死锁：** 破坏产生死锁的4个必要条件中的一个或几个，比如：

   - 破坏互斥条件：允许系统资源都能共享使用（不可行）
   - 破坏请求和保持条件：一次性分配所有资源，这样就不会再有请求了，只要有一个资源得不到分配，就不给这个进程分配其他的资源；
   - 破坏不可剥夺条件：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，就让它释放已经保持的所有资源，待以后需要时再重新申请
   - 破坏循环等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反

2. **避免死锁：** 合理分配资源，以防止系统进入不安全状态。比如银行家算法

3. **检测死锁：** 检测方法是简化资源分配图，当资源分配图不可完全简化时，则为死锁

4. **解除死锁：**

   解除死锁的主要方法有：

   - 资源剥夺法：
   - 撤销进程法：
   - 进程回退法：



## 13. 怎么预防死锁？

- 破坏互斥条件：允许系统资源都能共享使用（不可行）
- 破坏请求和保持条件：一次性分配所有资源，这样就不会再有请求了，只要有一个资源得不到分配，就不给这个进程分配其他的资源；
- 破坏不可剥夺条件：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，就让它释放已经保持的所有资源，待以后需要时再重新申请
- 破坏循环等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反





## 15. 怎么解除死锁？

1. 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
2. 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
3. 进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。



## 16. 什么是缓冲区溢出？有什么危害？

缓冲区为暂时置放输出或输入资料的内存。

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。

计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。



## 17. 分页与分段的区别？

1. 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；
2. 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；
3. 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
4. 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。



## 18. 物理地址、逻辑地址、虚拟内存的概念

1. **物理地址：** 它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
2. **逻辑地址：** 是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。
3. **虚拟内存：** 是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。



## 19. 页面置换算法有哪些？

请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。

常用的页面置换算法如下：

- **先进先出置换算法（FIFO）：**  先进先出，即淘汰最早调入的页面。
- **最佳置换算法（OPT）：** 选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小（不可实现）。
- **最近最久未使用（LRU）算法：** 选择最近最久未使用的页面予以淘汰
- **时钟（Clock）置换算法：** 时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。



## 21. 外中断和异常有什么区别？

- **外中断：** 是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
- **异常：** 是由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。



## 23. 什么是用户态和内核态

用户态和内核态是操作系统的两种运行状态。

- **内核态：** 处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。
- **用户态：** 处于用户态的 CPU 只能受限于访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。

那么为什么要有用户态和内核态呢？

这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。



## 25. 进程终止的方式

进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的

1. 正常退出(自愿的)
2. 错误退出(自愿的)
3. 严重错误(非自愿的)
4. 被其他进程杀死(非自愿的)

**正常退出**

多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 `exit` ，在 Windows 中是 `ExitProcess`。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。

**错误退出**

进程发生终止的第二个原因是发现错误，比如用户给出了错误参数，这时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。

**严重错误**

进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。

**被其他进程杀死**

第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 `TerminateProcess`（注意不是系统调用）。











