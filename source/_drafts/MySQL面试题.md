---
title: MySQL面试题
comment: true
date: 2022-01-24 21:21:32
tags:
categories:
addrlink:
---

## 1. 请说下你对 MySQL 架构的了解？

![img](D:\blog\source\_drafts\MySQL面试题\1.png)

MySQL基架大致包括如下几大模块组件：

1. **MySQL向外提供的交互接口（Connectors）：** 

   是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。

2. **管理服务组件和工具组件(Management Service & Utilities)：** 

   提供对MySQL的集成管理，如备份(Backup),恢复(Recovery),安全管理(Security)等

3. **连接池组件(Connection Pool)：** 

   负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。

4. **SQL接口组件(SQL Interface)：** 

   接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。

5. **查询分析器组件(Parser)：** 

   首先分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。

6. **优化器组件（Optimizer）：** 

   对SQL命令按照标准流程进行优化分析。

7. **缓存组件（Caches & Buffers）：** 

   缓存和缓冲组件。然而，MySQL查询是不建议使用缓存的，在MySQL中，我们大部分表中的值是更新的比较频繁的，一旦表中的值改变了，那么对应的缓存也要改变，缓存的修改过于频繁，对于数据库也是一种负担。因此在MySQL8.0版本的时候就将缓存的功能删除掉了。

8. **插件式存储引擎（Pluggable Storage Engines）：** 

   负责数据的存储和提取，其架构是插件式的，支持 InnoDB、MyISAM 等多个存储引擎。

9. **物理文件（File System）：** 

   实际存储MySQL 数据库文件和一些日志文件等的系统



## 2. 一条 SQL 语句在数据库框架中的执行流程？

执行一条SQL语句，会经过以下组件：

1. **连接器：** 

   - 先登录数据库，连接器会进行用户的身份认证（账号密码的验证）

   - 如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。

2. **缓存组件：** 

   - 在该组件中做查询缓存的工作
   - 查询缓存主要是涉及 `SELECT` 语句部分的。当执行`SELECT` 语句的时候，他会先查询MySQL中的缓存中有没有要查询的数据，如果缓存中有，那么就直接返回缓存中的内容。如果没有，那么在sql语句执行完毕之后，会将查询的结果以key-value的形式缓存下来，当以后相同的语句执行的时候，就可以直接返回缓存中的内容。
   - 但是大多数情况下不建议使用查询缓存 ---> 因为查询缓存往往弊大于利。在MySQL中，我们大部分表中的值是更新的比较频繁的，一旦表中的值改变了，那么对应的缓存也要改变，缓存的修改过于频繁，对于数据库也是一种负担。因此在MySQL8.0版本的时候就将缓存的功能删除掉了。

3. **查询分析器组件： ** 

   - 如果没有命中查询缓存，就要开始正真执行语句了。首先，MySQL 需要知道你要做什么，因此要对 SQL 语句做解析。
   - 分析器先对 SQL 语句作词法分析，找出sql语句中的关键词，比如像select啦、表名啦、查询条件等等
   - 接着分析器会对SQL语句作语法分析，判断sql语句是否合法

4. **优化器组件：** 

   优化器会确定SQL语句的执行顺序

5. **执行器：** 

   MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入执行器阶段，开始执行语句。

   - 开始执行的时候，要先判断一下你对SQL语句中的表有没有相关的权限，如果没有，就会返回没有权限的错误。
   - 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
   - 最后将查询结果返回给客户端。

6. **存储引擎：** 

   调用对应的存储引擎对数据进行读取和存储

![img](D:\blog\source\_drafts\MySQL面试题\2.jpg)



- 查询SQL语句流程：

  ![img](D:\blog\source\_drafts\MySQL面试题\3.jpg)

- 修改SQL语句流程：

  ![img](D:\blog\source\_drafts\MySQL面试题\4.jpg)



## 3. 数据库的三范式是什么？

1. **第一范式：** 强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；
2. **第二范式：** 要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；
3. **第三范式：** 任何非主属性不依赖于其它非主属性。



## 4. char 和 varchar 的区别？

- **char(n) ：**

  固定长度类型，比如：订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。

  优点：由于char是固定长度的所以它的处理速度比varchar快很多。

  缺点：占用空间；还有读取char类型数据时候时如果尾部有空格会丢失空格。

  适用场景：存储密码的 md5 值，固定长度的、长度变化不大的、并且对查询速度有较高要求，使用 char 非常合适。

- **varchar(n) ：**可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。

所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。



## 5. varchar(10) 和 varchar(20) 的区别？

对于存储长度小于10的字符串，varchar(10) 和 varchar(20) 所占用的磁盘空间是一样的，

但会有以下不一样：消耗的内存不一样，更长的列消耗的内存会更多，尤其是排序时。

所以在设计表时，我们不能太过浪费内存空间，还是需要评估实际使用的长度来设置字符的长度。***推荐冗余10%的长度***（因业务而异）。



## 6. 谈谈你对索引的理解？

索引的出现是为了提高数据的查询效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。

同样索引也会带来很多负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。

**建立索引的原则：**

1. 在最频繁使用的、用以缩小查询范围的字段上建立索引；
2. 在频繁使用的、需要排序的字段上建立索引。

**不适合建立索引的情况：**

1. 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；
2. 对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。



## 7. 索引的底层使用的是什么数据结构？

索引的数据结构和具体存储引擎的实现有关,，在MySQL中使用较多的索引有 **Hash 索引**、**B+树索引**等。

而我们经常使用的 InnoDB 存储引擎的默认索引实现为 B+ 树索引。



## 8. 谈谈你对 B+ 树的理解？







## 22. 谈谈你对数据库读写分离的理解？

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

![这里写图片描述](D:\blog\source\_drafts\MySQL面试题\5.jpg)

**读写分离能提高性能的原因在于：**

1. 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
2. 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
3. 增加冗余，提高可用性。



## 23. 请你描述下事务的特性？

1. 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性：执行事务前后，数据库从一个一致性状态转换到另一个一致性状态。
3. 隔离性：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



## 24. 谈谈你对事务隔离级别的理解？

1. READ_UNCOMMITTED（未提交读）: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；
2. READ_COMMITTED（提交读）: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；
3. REPEATABLE_READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；
4. SERIALIZABLE（串行化）: 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。



## 25. 解释下什么叫脏读、不可重复读和幻读？

- **脏读：** 

  表示一个事务能够读取另一个事务中还未提交的数据。比如：某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

- **不可重复读 ：**

  是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题

  **不可重复读的重点是修改** ：同样的条件 , 你读取过的数据 , 再次读取出来发现值不一样了

- **幻读：**

  指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

  **幻读的重点在于新增或者删除**：同样的条件 , 第 1 次和第 2 次读出来的记录数不一样



## 26. MySQL 默认的隔离级别是什么？

MySQL默认采用的 REPEATABLE_READ隔离级别。

Oracle 默认采用的 READ_COMMITTED 隔离级别。



## 27. 谈谈你对MVCC 的了解？

**数据库并发场景：**

1. 读-读：不存在任何问题，也不需要并发控制；
2. 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；
3. 写-写：有线程安全问题，可能会存在更新丢失问题。

多版本并发控制（Multi-Version Concurrency Control，MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。

**MVCC 可以为数据库解决以下问题：**

1. 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；
2. 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。

具体可参考 [【MySQL笔记】正确的理解MySQL的MVCC及实现原理](https://blog.csdn.net/SnailMann/article/details/94724197) 

