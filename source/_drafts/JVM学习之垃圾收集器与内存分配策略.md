---
title: JVM学习之垃圾收集器与内存分配策略
comment: true
date: 2021-08-16 15:44:20
tags:
categories:
addrlink:
---

**垃圾收集**（**Garbage Collection**，**GC**），主要完成三件事情：

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？



在JVM中，==程序计数器==、==JVM栈==、==本地方法栈==，这三个区域有以下几个特性：

1. 随线程生而生，灭而灭
2. 栈中的栈帧随着方法的进入和退出，执行着入栈和出栈的操作
3. 每一个栈帧中分配多少内存，基本上在确定类结构时就是已知的

所以，这三个区域的==内存分配和回收都具备确定性==。



剩下的==Java堆==和==方法区==，它们内存的分配和回收是动态的，只有运行时才知道程序会创建哪些对象，创建多少个对象。

所以，JVM垃圾回收的目标就是这两个区。



# 对象已死？

GC在对堆进行回收前，第一件事就是要确定哪些对象还活着，哪些对象已死。

完成这一步，具体有以下几种方法：

1. 引用计数算法
2. 可达性分析算法



## 引用计数算法

引用计数算法，Reference Counting，其算法思想：

- 在对象中添加一个引用计数器。
- 每当有一个地方引用它时，计算器值就加一；当引用失效时，计数器值就减一。
- 当计数器值为0时，就意味着该对象已死。



虽然引用计数算法，原理简单高效，但主流的JVM里都没有选用该算法，因为该算法必须要配合大量的额外处理，才能保证正确地工作。

比如，当两个对象相互引用着对方时，即使这两个对象已不再被访问，但它们的引用计数都不为0，所以这两个对象也无法被回收。



## 可达性分析算法

可达性分析算法，Reachability Analysis。

目前主流的程序语言（Java，C#）的内存管理子系统，都是通过可达性分析算法来判断对象是否存活。



该算法的基本思路：

- 通过一系列称为“`GC Roots`”的根对象作为==起始节点集==。
- 从起始节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“==引用链（Reference Chain）==”。
- 如果某个对象到`GC Roots`间没有任何引用链相连，或者用图论的话说就是，从`GC Roots`到这个对象不可达时，那么此对象是不可能再被使用的。



![image-20210816172204052](D:\blog\source\_drafts\JVM学习之垃圾收集器与内存分配策略\1.png)



在Java技术体系中，==固定==，可作为`GC Roots`对象，包括以下几种：

1. JVM栈（栈帧中的本地变量表）中引用的对象
   - 如，各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 方法区中类静态属性引用的对象
   - 如，Java类的引用类型静态变量
3. 方法区中变量引用的对象
   - 如，字符串变量池（`String Table`）里的引用
4. 本地方法栈中JNI（JNI即：Native方法）引用的对象
5. JVM内部的引用
   - 如，基本数据类型对应的Class对象，一些常驻的异常对象（如`NullPointExcepition`、`OutOfMemoryError`），系统类加载器
6. 所有被同步锁（`synchronized`关键字）持有的对象
7. 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存



除了这些固定的`GC Roots`对象，根据用户所选用`GC`与当前回收的内存区域的不同，还可以有其他对象“临时性”地加入。



## 认识引用

==在JDK1.2前==，引用的定义为：如果`reference`类型的数据中存储的数值代表的是另外一块内存的起始地址，那么就称该`reference`数据是代表某块内存、某个对象的引用。

由于该定义对于描述一些“食之无味，弃之可惜”的对象显得无能为力，所以==在JDK1.2之后==，Java对引用进行了扩充，将引用分为4种：

1. 强引用，Strongly Reference
2. 软引用，Soft Reference
3. 弱引用，Weak Reference
4. 虚引用，Phantom Reference

这4种引用强度依次逐渐减弱。



**强引用：**

==最传统的“引用”的定义==，即程序代码中的引用赋值

在任何情况下，只要有强引用，GC就不能回收被引用的对象



**软引用：**

它用来描述一些==还有用，但非必须==的对象。

只被软引用的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。



**弱引用：**

它用来描述一些==非必须==的对象

被弱引用的对象，只能存活到下一次垃圾收集行为发生为止。即：当GC开始工作，无论当前内存是否足够，都会回收掉弱引用的对象。



**虚引用：**

它又称：==幽灵引用==、==幻影引用==

一个对象是否有虚引用，不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。

它的作用就是：在虚引用的对象被GC回收时收到一个系统通知。



## 生存还是死亡

即使对象在可达性分析中判定为不可达，但它也不是“非死不可”，此时它们还处于==“缓刑”==的阶段。

真正要宣告一个对象的死亡，至少要经历两次标记过程：

1. 在可达性分析中判定为不可达

2. 判断不可达的对象是否有必要执行`finalize()`方法。

   其中判断方法为：若对象没有覆盖`finalize()`方法，或着`finalize()`方法已被JVM调用过，那么JVM会将这两种情况都视为“没有必要执行”。



当对象被判定为“有必要执行`finalize()`方法时，该对象会被放置在`F-Queue`队列中，并由一条由JVM自动建立的、低调度优先级的`Finalizer`线程去==**执行**==它们的`finalize()`方法。

值得注意的是，这里的==**执行**==指的是：JVM会触发这个方法开始执行，但不承诺它一定会完成执行。



## 回收方法区

方法区的垃圾收集，主要回收两部分：

1. 废弃的常量
2. 不再使用的类型



判断变量A是否废弃：只需判断一下系统中是否还有变量的值等于变量A的值。

而判断一个类型是否废弃，需要满足三个条件：

1. 该类的所有==实例==都已被回收
2. 加载该类的==类加载器==已被回收
3. 该类对应的`java.lang.Class`对象没有被引用，无法通过反射访问该类的方法





# 垃圾收集算法

从如何判断对象消亡的角度出发，垃圾收集算法可分为：

1. 引用计数式垃圾收集（Reference Counting GC）
2. 追踪式垃圾收集（Tracing GC）

这两类也常被分别叫作：直接垃圾收集和间接垃圾收集。

在这里主要讨论：追踪式垃圾收集。





## 分代收集理论

分代收集，Generational Collection，它其实一套经验法则。

它建立在两个分代假说之上：

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

分代收集理论奠定了很多==垃圾收集器==的==设计原则==：

- 收集器应将Java堆划分为不同的区域
- 然后将回收对象依据其年龄分配到不同的区域中存储
- 这里的年龄指：对象熬过垃圾收集过程的次数



分代收集理论是接下来==标记-复制算法==、==标记-清除算法==、==标记-整理算法==的理论基础。







