---
title: mysql多版本并发控制学习
comment: true
date: 2022-02-12 09:56:34
tags:
categories:
addrlink:
---

# 数据库并发场景

数据库有三种并发场景：

1. ***读-读：*** 不存在任何问题，也不需要并发控制
2. ***读-写：*** 有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
3. ***写-写：*** 有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失



其中，多版本并发控制（MVCC）就是一种用来解决**读-写冲突**的***无锁并发控制*** ，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以 MVCC 可以为数据库解决以下问题：

1. 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
2. 解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题



至于 **写-写冲突** ，一般会采用悲观锁或者乐观锁。

所以，为了能最大程度地提高数据库并发性能，并解决读写冲突和写写冲突，一般就采用以下两种组合：

1. ***MVCC+悲观锁*** ：MVCC解决读写冲突，悲观锁解决写写冲突
2. ***MVCC+乐观锁*** ：MVCC 解决读写冲突，乐观锁解决写写冲突



# 当前读和快照读

在深入学习 MVCC 多版本并发控制之前，我们还得先了解一下，什么是 MySQL InnoDB 下的 ***当前读*** 和 ***快照读*** ？



## 当前读

**当前读，就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。** 下列操作都是一种当前读：

1. select...lock in share mode (共享读锁)
2. select...for update（排它锁）
3. update , delete , insert（排它锁）

例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。



## 快照读

**像不加锁的 select 操作（单纯的select操作）就是快照读，即不加锁的非阻塞读。**

- 对于隔离级别为Read Committed，每次select都生成一个快照读。
- 对于隔离级别为Repeatable Read，开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。
- 对于隔离级别为Serializable，快照读会退化成当前读。

快照读是为了提高高并发性能，而快照读的实现是基于多版本并发控制（MVCC）的，MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；但既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。



**其实 MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是`快照读`, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**



## 快照读与MVCC

- MVCC 多版本并发控制是 **「维持一个数据的多个版本，使得读写操作没有冲突」** 的概念，只是一个抽象概念，并非实现
- 因为 MVCC 只是一个抽象概念，要实现这么一个概念，MySQL 就需要提供具体的功能去实现它，**「快照读就是 MySQL 实现 MVCC 理想模型的其中一个非阻塞读功能」**。而相对而言，当前读就是悲观锁的具体功能实现



## 补充：隔离级别

SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级别一般支持更高的并发处理，并拥有更低的系统开销。

其中这4种隔离级别为：

1. ***Read Uncommitted（读取未提交内容）***
2. ***Read Committed（读取提交内容）***
3. ***Repeatable Read（可重读）***
4. ***Serializable（可串行化）***



### Read Uncommitted（读取未提交内容） 

**在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。**本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。

读取未提交的数据，也被称之为 ***脏读（Dirty Read）*** 。



### Read Committed（读取提交内容）

这是大多数数据库系统的默认隔离级别（如Oracle，但不是MySQL默认的）。**它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。**



不过，这种隔离级别导致了一个新的问题：**不可重复读（Nonrepeatable Read）**，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

> **不可重复读（Nonrepeatable Read）** 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
>
> 例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题
>
> **不可重复读的重点是修改** ：同样的条件 , 你读取过的数据 , 再次读取出来发现值不一样了



### Repeatable Read（可重复读）

**这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。**

至于是怎么解决不可重复读的？这就与 ***快照读*** 有关了，具体解决流程且看下文。



不过理论上，这会导致另一个棘手的问题：***幻读 （Phantom Read）***。

幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

> **幻读** 指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。
>
> **幻读的重点在于新增或者删除**：同样的条件 , 第 1 次和第 2 次读出来的记录数不一样
>
> **不可重复读与幻读的区别：** 
>
> - 不可重复读是查询==同一个数据==，发现跟刚才的不一样。
> - 幻读是比不可重复读高一个级别的错误，读取同一条数据发现跟刚才是一样的，而在读取==一堆数据==时发现忽然多一个或者少一个。
> - **综上，不可重复读针对的是同一条数据，幻读针对的是一片数据。**



### Serializable（可串行化）

这是最高的隔离级别，**它通过强制事务按顺序地逐个执行，因此各个事务间不可能产生冲突**，从而解决幻读问题。

但是这将严重影响程序的性能。通常情况下也不会用到该级别。



下面用一个表来总结一下上述的4种隔离级别：

| 隔离级别                         | 脏读 | 不可重复读 | 幻读 |
| -------------------------------- | ---- | ---------- | ---- |
| Read Uncommitted，读取未提交内容 | Yes  | Yes        | Yes  |
| Read Committed，读取提交内容     | No   | Yes        | Yes  |
| Repeatable Read，可重复读        | No   | No         | Yes  |
| Serializable，可串行化           | No   | No         | No   |



# MVCC

MVCC（Multi-Version Concurrency Control），即多版本并发控制。

MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

MVCC 在 **MySQL InnoDB** 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，**做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。**



## MVCC的实现原理

MVCC主要由 ***3个隐式字段*** 、 ***undo日志*** 、 ***Read View*** 来实现的。下面先分别说明一下这3个东西。



### 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的 `DB_TRX_ID` ， `DB_ROLL_PTR` ， `DB_ROW_ID` 

1. `DB_TRX_ID` ：6 byte，记录创建这条记录或者最后一次修改该记录的事务 ID
2. `DB_ROLL_PTR` ：7 byte，回滚指针，用于配合 undo日志，指向这条记录的上一个版本（存储于 rollback segment 里）
3. `DB_ROW_ID` ：6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以`DB_ROW_ID`产生一个聚簇索引



![在这里插入图片描述](D:\blog\source\_drafts\mysql多版本并发控制学习\1.png)



### undo日志

undo log 主要分为两种：

1. ***insert undo log：*** **在insert新记录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃**
2. ***update undo log：*** **事务在进行update或delete时产生的undo log，不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除，只有在快照读和事务回滚都不涉及该日志时，对应的日志才会被purge线程统一清除。**



`undo log` 实际上就是存在 `rollback segment` 中的旧记录链，而MVCC利用到的是 `update undo log` 。

下面通过一个例子来说明一下undo日志的运作：

1. 首先，有一个事务插入 persion 表一条新的记录，记录如下，`name` 为 Jerry , `age` 为 24 岁，`隐式主键`是 1，`事务 ID`和`回滚指针`，我们假设为 NULL

   ![img](D:\blog\source\_drafts\mysql多版本并发控制学习\2.png)

2. 接着，`事务1`对该记录的 `name` 做出了修改，改为Tom。该步骤具体流程如下：

   - 在`事务1`修改该行(记录)数据时，数据库会先对该行加`排他锁`
   - 然后把该行数据拷贝到 `undo log` 中，作为旧记录，既在 `undo log` 中有当前行的拷贝副本
   - 拷贝完毕后，修改该行`name`为Tom，并且修改隐藏字段的事务 ID 为当前`事务 1`的 ID, 我们默认从 `1` 开始，之后递增，回滚指针指向拷贝到 `undo log` 的副本记录，既表示我的上一个版本就是它
   - 事务提交后，释放锁

   ![img](D:\blog\source\_drafts\mysql多版本并发控制学习\3.png)

3. 接着，`事务2` 来修改 `person 表` 的同一个记录，将 `age` 修改为30岁。该步骤具体流程如下：

   - 在 `事务2` 修改该行数据时，数据库也先为该行加 `排他锁` 
   - 然后把该行数据拷贝到 `undo log` 中，作为旧记录，发现该行记录已经有 `undo log` 了，那么最新的旧数据作为链表的表头，插在该行记录的 `undo log` 最前面
   - 修改该行 `age` 为 30 岁，并且修改隐藏字段的事务 ID 为当前`事务 2`的 ID，那就是 `2` ，回滚指针指向刚刚拷贝到 `undo log` 的副本记录
   - 事务提交后，释放锁

   ![img](D:\blog\source\_drafts\mysql多版本并发控制学习\4.png)



可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的`undo log`成为一条记录版本线性表，既链表，`undo log` 的链首就是最新的旧记录，链尾就是最早的旧记录。

当然就像之前说的该 undo log 的节点可能是会 purge 线程清除掉，像图中的第一条 insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里。



### Read View

**Read View 是事务在进行==快照读==操作的时候生产的读视图（Read View），在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。**

在Read View中的数据，既可能是当前最新的数据，也有可能是该行记录的`undo log`里面的某个版本的数据。

除此之外，Read View里还包含以下内容： 

- 在执行`快照读`那刻，系统正活跃的事务 ID 列表 `trx_list`
- 创建 `Read View` 的事务ID
- `up_limit_id` ：trx_list 列表中事务 ID 最小的 ID，即：**活跃事务列表的最小事务ID值**
- `low_limit_id` ：快照读时刻系统尚未分配的下一个事务 ID ，也就是目前已出现过的事务ID的最大值 + 1，即：**系统最大的事务ID值**

可以想想，在生成快照时，不可能把整个数据库都复制一遍，只是把当前时刻的最新的数据复制一会而已，而那4个东西就是用来寻找当前时刻的最新数据的。

至于Read View是怎么生成快照的呢？且看下面的整体流程。



### 整体流程

在了解了 `隐式字段`，`undo log`， 以及 `Read View` 的概念之后，就可以来看看 MVCC 实现的整体流程是怎么样的了。下面用一个例子来说明一下。

1. 当`事务2`对某行数据执行了`快照读`，数据库为该行数据生成一个`Read View`读视图。其中 `Read View`里包含如下内容：

   - 在执行`快照读`那刻，系统正活跃的事务 ID 列表 `trx_list`
   - 创建 `Read View` 的事务ID
   - `up_limit_id` ：trx_list 列表中事务 ID 最小的 ID，即：**活跃事务列表的最小事务ID值**
   - `low_limit_id` ：快照读时刻系统尚未分配的下一个事务 ID ，也就是目前已出现过的事务ID的最大值 + 1，即：**系统最大的事务ID值**

   举一个例子。

   假设当前事务 ID 为 `2`，此时还有`事务1`和`事务3`在活跃中，`事务4`在`事务2`快照读前一刻提交更新了：

   | 事务1    | 事务2    | 事务3    | 事务4        |
   | -------- | -------- | -------- | ------------ |
   | 事务开始 | 事务开始 | 事务开始 | 事务开始     |
   | …        | …        | …        | 修改且已提交 |
   | 进行中   | 快照读   | 进行中   |              |
   | …        | …        | …        |              |

   这时 `事务2` 快照读时所生成的 `Read View` 会有如下内容：

   - `trx_list` 中有 `事务1` 和 `事务3`
   - 创建 `Read View` 的`事务ID 2`
   - `up_limit_id`为1
   - `low_limit_id` 为5

   ![img](D:\blog\source\_drafts\mysql多版本并发控制学习\5.png)

   

2. 此外，在这个例子中，只有`事务 4` 修改过该行记录，并在`事务 2` 执行`快照读`前，就提交了事务，所以当前该行当前数据的 `undo log` 如下图所示：

   ![img](D:\blog\source\_drafts\mysql多版本并发控制学习\6.png)

   其实 `事务2` 在快照读该行记录的时候，就会拿该行记录的 `DB_TRX_ID` 去跟 `up_limit_id` , `low_limit_id` 和`活跃事务 ID 列表( trx_list )`进行比较，判断当前`事务2`能看到该记录的版本是哪些。

   而关于可见性的规则如下：

   - 读某一行数据的时候，先判断他的事务ID是否小于 `up_limit_id`（活跃id列表最小值），是？可见；不是？继续往下判断。
   - 判断数据的事务ID是否大于 `low_limit_id`（ReadView时系统中最大的事务ID）
     - 是？不可见，转去 `undo log` 中寻找小于`low_limit_id` 的最新事务版本
     - 不是？继续往下判断。
   - 最后判断数据的事务ID是否在 `trx_list` 列表之内，
     - 是？该事务可见，此外该事务的 `undo log` 也是可见的；
     - 不是？转去 `undo log` 中寻找小于`low_limit_id` 的最新事务版本

   所以说， `事务2` 能看到的事务有1、2、3、4 。

   下图为可见性的规则的具体流程

   <img src="D:\blog\source\_drafts\mysql多版本并发控制学习\7.png" alt="在这里插入图片描述" style="zoom:120%;" />



## MVCC实现可重复读

MVCC是思想，快照读是实现MVCC思想的一种方案。所以说，Mysql InnoDB引擎实现RR（Repeatable Read）的，可以说是MVCC，也可以说是快照读。

至于是怎么解决的，且看下面例子。此外，也可以借着这个例子理解一下MVCC或者快照读是怎么解决读写冲突的。

例子一：

| 事务A                       | 事务B                                      |
| --------------------------- | ------------------------------------------ |
| 开启事务                    | 开启事务                                   |
| 快照读(无影响)查询金额为500 | 快照读查询金额为500                        |
| 更新金额为400               |                                            |
| 提交事务                    |                                            |
|                             | select `快照读`金额为500                   |
|                             | select lock in share mode`当前读`金额为400 |

在上表的执行顺序下，事务 B 在事务 A 提交修改前进行了一次快照读，在事务 A 提交修改后又进行了一次快照读，而第二次的快照读与第一次的快照读一样。而当前读是实时新数据 400。



例子二：

| 事务A                         | 事务B                                      |
| ----------------------------- | ------------------------------------------ |
| 开启事务                      | 开启事务                                   |
| 快照读（无影响）查询金额为500 |                                            |
| 更新金额为400                 |                                            |
| 提交事务                      |                                            |
|                               | select `快照读`金额为400                   |
|                               | select lock in share mode`当前读`金额为400 |

在上表的执行顺序下，事务 B 在事务 A 提交修改后才进行一次快照读，这时快照读的数据是事务A提交后的数据，与当前读的数据一样。





好了，讲完了解决读写冲突，接下来就是解决写写冲突了，解决写写冲突通常使用悲观锁或者乐观锁。



在学习悲观锁、乐观锁之前，得先清楚一些概念。

1. 悲观锁、乐观锁与MVCC，它们都是一种***锁的思想***。它们的概念不仅仅存在于数据库领域，还有线程安全等其他并发场景。不能与数据库中的表锁、页锁、行锁滚为一谈，它们并不是一个维度的东西。
2. 在数据库中，乐观锁又叫乐观并发控制（OCC），悲观锁又叫悲观并发控制（PCC），而MVCC则是一种区别于乐观锁与悲观锁的控制，叫多版本并发控制。



# 悲观锁

在数据库中，悲观锁又称悲观并发控制（Pessimistic Concurrency Control，PCC），是一种并发控制的思想。

**悲观锁指的是采用一种持悲观消极的态度，默认数据被外界访问时，必然会产生冲突，所以在数据处理的整个过程中都采用加锁的状态，保证同一时间，只有一个线程可以访问到数据，实现数据的排他性。**



## 悲观锁的实现

通常，数据库的悲观锁是利用数据库本身提供的锁机制去实现的。其总体流程如下：

1. 外界要访问某条数据，那它就要首先向数据库申请该数据的锁（某种锁）。
2. 如果获得成功，那它就可以操作该数据，在它操作期间，其他客户端就无法再操作该数据了。
3. 如果获得失败，则代表同一时间已有其他客户端获得了该锁，那就必须等待其他客户端释放锁。

当然数据库提供了非常多的锁，每种数据库提供的锁也不尽然相同，所以具体情况就要看是什么锁了，比如行锁，表锁等。



## 优缺点

- 优点：适合在写多读少的并发环境中使用，虽然无法维持非常高的性能，但是在乐观锁无法提更好的性能前提下，可以做到数据的安全性。
- 缺点：加锁会增加系统开销，虽然能保证数据的安全，但数据处理吞吐量低，不适合在读多写少的场合下使用。



总的来讲，悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。



# 乐观锁

在数据库中，乐观锁又称乐观并发控制（Optimistic Concurrency Control，OCC），是一种并发控制的思想。

与悲观锁对比，乐观锁（ `Optimistic Locking` ） 认为即使在并发环境中，外界对数据的操作一般是不会造成冲突，所以并不会去加锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回冲突信息，让用户决定如何去做下一步，比如说重试，直至成功为止。

数据库的乐观锁，并不是利用数据库本身的锁去实现的，可能是利用某种实现逻辑去实现做到乐观锁的思想。



## CAS思想

数据库乐观锁的具体实现几乎跟Java中乐观锁采用的CAS算法思想一致，因此我们可以从CAS算法中学习到数据库乐观锁的设计：

CAS指令全称为Compare and Swap，它是系统的指令集，整个CAS操作是一个原子操作，是不可分割的。

CAS的三元素：

1. 一个内存的地址值：stateoffset
2. 期望的值：expect
3. 一个新值：update

实现步骤：

1. 获取地址stateOffset上的值value；
2. 判断value和期望的值expect是否相等，若相等就给地址stateOffset赋新值update；
3. 否则：循环重复步骤1-2；

当地址stateOffset上的值value不等于expect时，就说明有其他的线程修改过了地址stateOffset上的值value，比如线程2在线程1修改value前就更新了value，所以线程1会更新变量i失败。**但线程不会挂起，而是返回失败状态，等待调用线程决定是否重试或其他操作。（通常会重试直到成功）**



Java对CAS的实现：

```java
// 这是官方给出的CAS操作方法:
public final boolean compareAndSet(int expect, int update) {
	 /**
 		unsafe.compareAndSwapInt(this, valueOffset, expect, update);
 		this: 代表当前原子操作类对象
 		valueOffset: 内存偏移量,地址址
 		update: 要操作的变量值
    */
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

```java
public final class Unsafe {
	// compareAndSwapInt方法被native修饰,说明unsafe类底层调用的其他语言的接口,
    // CAS原并发语句体现在java的sun.misc.Unsafe类中的各个方法,
    // JVM会帮我们实现CAS汇编语言.一种完全依赖硬件的语言,通过它实现 原子操作.
    public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
}
```



## 数据库中乐观锁的实现

通常乐观锁的实现有两种，但它们的内在都是CAS思想的设计：

1. 基于数据版本（`version`）的实现
2. 基于时间戳（`timestamp`）的实现



### 基于数据版本

- 这是乐观锁最常用的一种实现方式。什么是数据版本呢？就是在表中增添一个字段作为该记录的版本标识，比如叫 `version` ，每次对该记录的写操作都会让 `version+ 1`。
- 所以当我们读取了数据（包括`version`），做出更新，要提交的时候，就会拿取得的 `version` 去跟数据库中的 `version` 比较是否一致，如果一致则代表这个时间段，并没有其他的线程的也修改过这个数据，给予更新，同时 `version + 1` ；如果不一致，则代表在这个时间段，该记录以及被其他线程修改过了， 认为是过期数据，返回冲突信息，让用户决定下一步动作，比如重试（重新读取最新数据，再过更新）
- `update table set num = num + 1 , version = version + 1 where version = #{version} and id = #{id}` 



### 基于时间戳

- 表中增加一个字段，名称无所谓，比如叫`update_time`, 字段类型使用时间戳（`timestamp`）
- 原理和方式一一致，也是在更新提交的时检查当前数据库中数据的时间戳和自己更新前取到的时间戳是否一致，如果一致则代表此刻没有冲突，可以提交更新，同时时间戳更新为当前时间，否则就是该时间段有其他线程也更新提交过，返回冲突信息，等待用户下一步动作。
- `update table set num = num + 1 ,update_time = unix_timestamp(now()) where id = #{id} and update_time = #{updateTime}`



值得注意的是，在实现乐观锁思想的同时，我们必须**要保证CAS多个操作的原子性，即：获取数据库数据的版本，拿数据库的数据版本与之前拿到的版本的比较，以及更新数据等这几个操作的执行必须是连贯执行，具有复合操作的原子性；所以如果是数据库的SQL，那么我们就要保证多个SQL操作处于同一个事务中。**



## 优缺点

**优点：**

- 在读多写少的并发场景下，可以避免数据库加锁的开销，提高Dao层的响应性能

- 其实很多情况下，我们ORM工具都有带有乐观锁的实现，所以这些方法不一定需要我们人为的去实现

  > ORM，Object Relational Mapping，对象关系映射。
  >
  > ORM是通过描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 
  >
  > ![在这里插入图片描述](D:\blog\source\_drafts\mysql多版本并发控制学习\8.png)
  >
  > 常见的ORM框架有：Mybatis、Hibernate、Spring Data JPA、Mybatis Plus等等。

**缺点：**

- 在写多读少的并发场景下，即在写操作竞争激烈的情况下，会导致CAS多次重试，冲突频率过高，导致开销比悲观锁更高



# 悲观锁、乐观锁与MVCC

## 乐观锁和悲观锁的抉择

对乐观锁和悲观锁的抉择主要体现在 ***写-写冲突*** 上。

在悲观锁和乐观锁的抉择中，我们可以从下面三个因素来考虑：

1. **响应速度：** 如果Dao层需要非常高的响应速度，尤其是读多写少的场景下，那我们就可以采用乐观锁方案，降低数据库锁的开销，提供并发量
2. **冲突频率：** 如果冲突频率非常高，那么我们就可以采用悲观锁，保证成功率；毕竟如果冲突频率大，乐观锁会需要多次重试才能成功，代价可能会大大增加
3. **重试代价：** 如果重试代价大，比如说重试过程的代码执行非常耗时，那么此时我就不建议使用乐观锁了，还不如直接上悲观锁来了爽快



所以我们知道：

- 在读多写少，CAS竞争没这么激烈的时候，我们可以采用乐观锁策略，降低数据库加锁的开销，提高数据库并发响应
- 在写多读少的场景下，因为会产生大量的CAS竞争，且重试成本比较高的情况下，我们就不建议再采用乐观锁策略了，还是直接使用悲观锁的数据库加锁吧



## 三者关系

- ***悲观并发控制（PCC）*** 是一种用来解决`读-写冲突`和`写-写冲突`的**加锁并发控制** 

  为每个操作都加锁，同一时间下，只有获得该锁的事务才能有权利对该数据进行操作，没有获得锁的事务只能等待其他事务释放锁；

  所以可以解决脏读，幻读，不可重复读，第一类更新丢失，第二类更新丢失的问题

- ***乐观并发控制（OCC）*** 是一种用来解决`写-写冲突`的**无锁并发控制**

  认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自旋锁。

  乐观并发控制适用于低数据争用，写冲突比较少的环境；无法解决脏读，幻读，不可重复读，但是可以解决更新丢失问题

- ***多版本并发控制（MVCC）*** 是一种用来解决`读-写冲突`的**无锁并发控制**

  也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 

  这样在读操作时就不用阻塞写操作，写操作也不用阻塞读操作；不仅可以提高并发性能，还可以解决脏读，幻读，不可重复读等事务问题。更新丢失问题除外。



总的来说，MVCC的出现就是数据库不满用悲观锁去解决读-写冲突问题，因性能不高而提出的解决方案，所以数据库在应对并发控制的问题上，形成了两个组合：

- ***MVCC + 悲观锁*** ：MVCC解决读-写冲突，悲观锁解决写写冲突
- ***MVCC + 乐观锁*** ：MVCC解决读写冲突，乐观锁解决写写冲突

这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题





接下来学习另一种维度的锁：Mysql在三种层级的锁定。



# Mysql三种层级的锁定

MySQL支持三种层级的锁定，分别为

1. **表级锁定**
   表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的 MyISAM 与 InnoDB 都支持表级锁定

2. **页级锁定**
   页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁

   > BDB（Berkeley DB）数据库，是一种嵌入式数据库，Key-Value型的数据库，不支持SQL语言。

3. **行级锁定**
   行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大

**从上到下，锁的粒度逐渐细粒化, 但实现开销逐渐增大。** 

同时我们也要须知，**表锁，页锁，行锁并不是一个具体的锁，仅代表将数据库某个层级上的数据进行锁定。具体怎么去锁这个数据，还要看具体的锁实现是什么**

![在这里插入图片描述](D:\blog\source\_drafts\mysql多版本并发控制学习\9.png)





# InnoDB支持的锁

以下讨论的Mysql版本是8.0以上的。



从官方文档 [15.7.1 InnoDB Locking](https://blog.csdn.net/SnailMann/article/details/88353099) 中，可以看到InnoDB支持以下几种具体的锁：

1. **共享锁和排他锁 (Shared and Exclusive Locks)** 
2. **意向锁（Intention Locks）**
3. **记录锁（Record Locks）**
4. **间隙锁（Gap Locks）**
5. **临键锁 （Next-Key Locks）**
6. **插入意向锁（Insert Intention Locks）**
7. 主键自增锁（AUTO-INC Locks）
8. 空间索引断言锁（Predicate Locks for Spatial Indexes）



InnoDB支持表级锁定和行级锁定。不过表锁和行锁并不是一个真正的锁，只是代表可以对数据库对应层级的数据进行锁定。具体以什么形式去锁定，则要看具体的具体锁实现。

- 表锁具体的锁实现则有共享锁，排他锁，意向锁等。
- 行锁具体的锁实现则有共享锁和排他锁，另外行锁本身还有记录锁，间隙锁和临键锁的不同算法实现。

![在这里插入图片描述](D:\blog\source\_drafts\mysql多版本并发控制学习\10.png)



**那是不是行级锁一定比表级锁要好呢？**

- 那到未必，锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价其实是比较高的
- 总之，锁的粒度越细，需要实现的开销越大，所以表锁和行锁各有好处



下面主要讲讲InnoDB提供的前6种具体的锁。



## 共享锁和排他锁

- ***共享锁（Shared Lock）*** ，既称S锁，又称读锁。

  事务拿到某一行记录的S锁，才可以读取这一行的数据。共享锁可以实现读读共享，读写互斥

- ***排他锁（Exclusive Lock）*** ，既称X锁，又称写锁，独占锁。

  事务拿到某一行记录的X锁，才可以修改或者删除这一行的数据。排他锁可以实现读写互斥，写写互斥



由于共享锁和排他锁可以用于实现表锁和行锁，所以它们又可分为以下4种：

1. **表级共享锁** ，又称 **表共享读锁** ，即：在表的层级上对数据加以共享锁，实现读读共享
2. **表级排他锁** ，又称 **表独占写锁** ，即：在表的层级上对数据加以排他锁，实现读写互斥，写写互斥
3. **行级共享锁** ，即：在行的层级上，对数据加以共享锁，实现对该行数据的读读共享
4. **行级排他锁** ，即：在行的层级上，对数据加以排他锁，实现对该行数据的读写互斥，写写互斥



多个事务可以拿到一把S锁，可以实现读读共享；而只有一个事务可以拿到X锁，可以实现读写互斥，写写互斥。



### SQL应用

- `select * from table lock in share mode` 为table的所有数据加上共享锁，即： **表级共享锁** 
- `select * from table for update` 为table的所有数据加上排他锁，即： **表级排他锁** 
- `select * from table where id = 1 for update` 为table中id为1的那行数据加上排他锁，即： **行级排他锁** 
- `select * from table where id = 1 lock in share mode` 为table中id为1的那行数据加上共享锁，即： **行级共享锁** 

注意，加的是行锁的前提是，**id为主键且在查询命中**，否则行锁会轮为表锁



## 意向锁

通常情况下，表锁和行锁是相互冲突的，既获得了表锁，就无法再获得该表具体行的行锁，反之亦然。但是有的时候表锁和行锁实现部分的共存有利于更细粒度的对锁进行控制，以便得到更加的并发性能。所以InnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许一个事务中同时存在行锁和表锁。

所以InnoDB为了**实现行锁和表锁共存的多粒度锁机制**，就出现了 ***意向锁（Intention Lock）*** 。



**意向锁（Intention Lock）就是一种不与行级锁冲突的*表级锁*** ，其主要目的是：展示出某事务已对表中的某行加锁，或即将对表中的某行加锁，即在未来的某个时刻，事务可能要对某行加共享锁或排它锁了，先提前声明一个意向。

> 若将上锁对象看作成一颗树，那么对最下层的对象进行加锁，也就是对最细粒度的对象加锁，那么首先就需要先对上层的粗粒度的对象进行上锁。   ————《MySQL技术内幕》



然后，意向锁又可具体分为以下两种：

1. **意向共享锁（Intention Shared Lock，IS）：** 事务**打算**给表中的某些行加行级共享锁，**事务在给 `某些行` 加 `S锁` 前必须先取得该表的 `IS锁` 。**
2. **意向排他锁（Intention Exclusive Lock，IX）：** 事务**打算**给表中的某些加行级排他锁，**事务在给 `某些行` 加 `X锁` 前必须先取得该表的 `IX锁` 。**

总之意向锁，就是提前表明了要加行锁的“意向”。

**当某表存在排他意向锁时，那么该表的某行可能存在行级排他锁。同理当某表存在共享意向锁时，那么该表的某行可能存在行级共享锁。**







# 参考

1. [【MySQL笔记】正确的理解MySQL的MVCC及实现原理](https://blog.csdn.net/SnailMann/article/details/94724197)
2. [真正理解Mysql的四种隔离级别](https://www.jianshu.com/p/8d735db9c2c0)
2. [mysql幻读和不可重复读的区别](https://blog.csdn.net/a274537260/article/details/80356821)
2. [Mysql MVCC机制原理详解](https://www.jb51.net/article/210018.htm)
2. [Mysql MVCC 原理 low_limit_id ReadView](https://blog.csdn.net/waltonhuang/article/details/105850745)
2. [【MySQL笔记】正确的理解MySQL的乐观锁，悲观锁与MVCC](https://blog.csdn.net/SnailMann/article/details/88388829)
2. [CAS思想](https://blog.csdn.net/gogokongyin/article/details/110100423)
2. [java的CAS思想](https://blog.csdn.net/qq_36178454/article/details/98792396)
2. [几种常见的ORM框架](https://blog.csdn.net/J080624/article/details/118458521)
2. [ORM框架简介](https://blog.csdn.net/u012135009/article/details/88361374)
2. [ORM框架简介及优缺点 ](https://www.cnblogs.com/wfy680/p/14972285.html)
2. [【MySQL笔记】正确的理解MySQL中让你想到就烦的各种锁（一）](https://blog.csdn.net/SnailMann/article/details/88353099)
2. [15.7.1 InnoDB Locking](https://blog.csdn.net/SnailMann/article/details/88353099)

