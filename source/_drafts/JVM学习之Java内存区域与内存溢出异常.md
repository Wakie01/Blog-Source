---
title: JVM学习之Java内存区域与内存溢出异常
comment: true
date: 2021-08-07 16:28:00
tags:
categories:
addrlink:
---



# 概述

与C不同，在Java中，变量的内存管理是由JVM管理的，程序员不用为每个New操作去写delete/free代码



# 运行时数据区域

JVM在执行Java程序时，会把它所管理的内存划分为多个不同的==***数据区域***==

<img src="D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\1.jpg" alt="查看源图像"  />



## 程序计数器

程序计数器，Program Counter Register，是一块==较小==的***内存空间***

**作用：** 指挥当前线程执行字节码文件的哪一行，相当于一个==行号指示器==



> **字节码解释器**工作时就是，通过改变这个计数器的值，来选取下一条需要执行的字节码指令。



在这里或许要插入了解一下Java程序的执行过程。



回到程序计数器。

在JVM中，为了保证各个线程正确的执行，每个线程都会有一个==独立==的程序计数器，各个线程间的计数器互不影响，==独立存储==。所以，它是**线程私有**的内存，即：**线程隔离的数据区**。

由此可见，程序计数器的生命周期与线程相同。



值得注意的是，程序计数器是唯一一个没有`OutOfMemoryError`情况的内存区域



### Java程序的执行过程

![preview](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\2.jpg)

1. **编写：** 编写Java源代码，形成`.java`的Java源文件
2. **编译：** Java编译器将Java源文件编译成`.class`的字节码文件，在这过程中，Java编译器会对Java源文件进行基本的语法错误排查
3. **运行：** JVM将字节码文件翻译成机器代码，然后执行。在这过程中：
   - 首先是JVM中的**类加载器（Class Loader）**加载字节码文件
   - 然后是JVM中的**执行引擎（Execution Engine）**找到入口方法`main()`，并执行其中的方法

> Java解释器是JVM的一部分

![image-20210807172133674](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\3.png)





## Java虚拟机栈

Java虚拟机栈，Java Virtual Machine Stack。

它也是**线程私有**的，它的**生命周期与线程相同**，即：与线程共生死。



JVM栈，描述的是Java方法执行的**线程内存模型**：每个方法被执行时，JVM都会创建一个**栈帧（Stack Frame）**，用于存储该方法的一系列基本信息，而这个栈帧就存储在JVM栈中。

每个方法从调用到结束的过程，就对应着一个栈帧在JVM栈中从入栈到出栈的过程。

![img](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\4.png)



在一个栈帧中，它存储了该方法的一系列基本信息，如：局部变量表、操作数栈、动态连接、方法出口等。

关于局部变量表。

局部变量表存放了基本数据类型、对象引用（`reference`类型）和`returnAddress`类型。

- 基本数据类型：boolean、byte、char、short、int、float、long、double
- 对象引用：指向对象起始地址的引用指针，或者是指向与该对象相关的位置
- returnAddress：指向下一条字节码指令的地址

局部变量表所存放的数据，在==编译==时就可确定下来，所以，局部变量表所需要的内存空间是在编译期间完成分配的。

此外，局部变量表的存储空间是以**局部变量槽（Slot）**为单位的。

![img](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\5.png)



JVM栈有两个异常：`StackOverflowError`与`OutOfMemoryError`

- 当线程请求JVM栈的深度，大于JVM所允许的深度，则抛出`StackOverflowError`
- 若JVM栈的容量可以动态扩展，当JVM栈扩展时无法申请到足够的内存时，则抛出`OutOfMemoryError`



值得注意的是，HotSpot虚拟机的栈容量的不可以动态扩展的



## 本地方法栈

本地方法栈，Native Method Stacks

它与JVM栈非常类似。其区别只是：

- JVM栈：为Java方法（字节码）服务
- 本地方法栈：为本地（Native）方法服务



> 在Java中，有两种方法：
>
> - Java方法：由Java编写，编译成字节码文件
> - 本地方法：由其他语言编写，编译成和处理器相关的机器代码
>
> 本地方法保存在动态链接库中，其文件格式跟平台系统相关，比如Windows系统则是`.dll`文件
>
> Java方法则是与平台无关
>
> 
>
> **为什么要使用Native Method呢？**
>
> 因为Java虽然使用方便，但是有些层次的任务用Java不容易实现，或者Java实现时的效率比较低。而且有时Java应用需要与Java外部的环境交互。
>
> 
>
> **Native Method是怎样的呢？**
>
> Native Method就是一个java调用非java代码的接口。示例：
>
> ```java
> //Native Method接口
> public native void native1(){
>     ……
> }
> public native static long native2(){
>     ……
> }
> ```
>
> 标识符`native`可以与所有其它的Java标识符连用，但是`abstract`除外，因为`native`意味着这些方法是有实现体的，只不过这些实现体是非Java的，而`abstract`则代表这些方法没有实现体，这是相互矛盾的。
>
> 还有，一个Native Method可以返回任何Java类型，包括非基本类型，而且同样可以进行异常控制。
>
> 此外，Native Method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。



然而，《Java虚拟机规范》对本地方法栈中方法使用的==语言==、==使用方式==与==数据结构==并没有任何强制规定，因此，具体的JVM可以根据自己的需要来实现它。

当然也有的JVM直接==把本地方法栈和JVM栈合二为一==，比如Hot-Spot虚拟机。



## Java堆

Java堆，Java Heap，是这5块内存区域中==最大==的一块，而且它是==线程共享==的

它在JVM启动时创建

它的作用就是：存放对象实例。几乎所有的对象实例都是在这里分配内存的。

从分配内存的角度看，Java堆可以划分出多个==线程私有==的==分配缓冲区（Thread Local Allocation Buffer，TLAB）==，这样有助于提升给对象分配内存的效率。



Java堆是垃圾收集器管理的内存区域，所以它也叫“GC堆”，Garbage Collected Heap。

从回收内存的角度看，由于现代垃圾收集器大部分都是基于==分代收集理论==设计，所以Java堆中又可划分为`新生代`、`老年代`、`永久代`、`Eden空间`、`From Survivor空间`、`To Survivor空间`等等。



根据《Java虚拟机规范》的规定，Java堆的内存空间在物理上可以不连续，但在逻辑上应是连续的。

但对于大对象，JVM为了简单高效，往往会要求连续的内存空间。



目前主流的JVM的Java堆都是可扩展的。

当Java堆中没有内存完成实例分配，且Java堆也无法再扩展时，就会出现`OutOfMemoryError`异常。



## 方法区

方法区，Method Area，线程共享。

用于存储已被JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

值得注意的是，垃圾收集行为在方法区中比较少出现，因为比较难。

根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出`OutOfMemoryError`异常。



### 运行时常量池

运行时常量池，Runtime Constant Pool，是方法区的一部分。

`.class`文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是**常量池表（Constant Pool Table）**，它用于存放编译期生成的各自字面量与符号引用。

常量池表会在类加载后存放到方法区的运行时常量池中。



《Java虚拟机规范》对运行时常量池并没有做任何细节的要求。人们可以根据自己的需要来实现这个内存区域。



运行时常量池，相对于==Class文件常量池==的一个重要区别是：它具有==动态性==。常量池表在运行期间可以动态改变，在运行期间可以将新的常量放入池中，比如`String`类的`intern()`方法。

> `intern()`语法：
>
> ```java
> public String intern();
> ```
>
> 它返回字符串对象的规范化表示形式。
>
> 它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。
>
> 值得注意的是，它是一个Native方法。查看源码可见：
>
> ```java
> public final class String implements java.io.Serializable, Comparable<String>, CharSequence{
>     ……
>     public native String intern();
> }
> ```



既然运行时常量池是方法区的一部分，自然受到方法区内存的限制

当常量池无法再申请到内存时会抛出`OutOfMemoryError`异常。



## 直接内存

直接内存，Direct Memory，它==不是==JVM运行时数据区的一部分，也==不是==《Java虚拟机规范》中定义的内存区域。

但，这部分内存被频繁低使用。

它常用于为==Native方法==直接分配==堆外内存==。也就是说，它是为Native方法服务的。这样能避免在Java堆和Native堆中来回复制数据，从而提高性能。

> 堆外内存：指的是Java堆外的内存



当直接内存申请内存失败时，就会报`OutOfMemoryError`异常。



# HotSpot虚拟机对象探秘

在这里会深入探讨一下，最常用的HotSpot虚拟机，在Java堆中，对象分配、布局和访问的全过程。



## 对象的创建

当JVM遇到一条字节码`new`指令时，

1. 首先要，检查`new`指令的参数是否能在==常量池==（属于==方法区==）中找到该类的==符号引用==
2. 接着，检查该符号引用所代表的类，是否已被==加载==、==解析==和==初始化==，若没有，则进行类加载
3. 最后，就是给新生对象分配内存了



对象所需内存的大小，在类加载完成后就可完全确定。

给对象分配空间，相当于把一块确定大小的内存块从==Java堆==中划分出来。

那么划分呢？这就得看Java堆中的内部结构了：**绝对规整**和**不规整**。

1. **绝对规整**

   - 绝对规整指：所有使用过的内存和空闲的内存各放一边，中间放一个指针作为分界点。

   - 分配内存的过程就是：将指针，往空闲内存方向，挪动一段，与对象大小相等的距离。这种分配方式叫：==指针碰撞（Bump The Pointer）==。

2. **不规整**

   - 不规整指：已被使用的内存和空闲的内存相互交错在一起。
   - 这时就无法进行指针碰撞了。
   - JVM得维护一个列表，记录哪些内存块是可用的。在分配时，就从该列表中找一块足够大的空间划分给对象实例，并对该列表进行更新。这种分配方式叫：==空闲列表（Free List）==。



可见，选择哪种分配方式，由Java堆是否规整来决定；而Java堆是否规整则是由所采用的==垃圾收集器==是否带有==空间压缩整理==的能力来决定。



此外，还有一个问题：如何保证划分内存的动作在并发情况下是线程安全的？

解决这个问题有两种可选方案：

1. 对分配内存空间的动作进行同步处理

   JVM采用CAS+失败重试的方式可保证更新操作的原子性

   > CAS：Compare And Swap，比较交换。
   >
   > 其执行函数为：`CAS(V,E,N)`，其中参数含义：
   >
   > - V：要更新的变量的值
   > - E：预期值
   > - N：新值
   >
   > 函数的具体操作：
   >
   > 1. 若`V=E`，则将V的值设为N。
   > 2. 若`V!=E`，则说明已经有其他线程做了更新，这时当前线程什么都不做。
   >
   > ![img](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\7.png)
   >
   > 
   >
   > CAS+失败重试：当更新操作失败后，选择重新读取该变量值，尝试再次修改该变量，直至成功。

2. 把内存分配的动作，按照线程划分在不同的空间之中进行

   即每个线程在Java堆中预先分配一小块内存，称：==本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）==。

   哪个线程要分配内存，就从自己的本地线程分配缓冲区中分配。

   当TLAB用完之后，就继续分配新的缓冲区，这时候才需要==同步锁定==。



好了，划分内存完成后，JVM还要对对象进行必要的设置，设置的信息会存放在对象的==对象头（Object Header）==中。



这时候，从JVM的视角来看，一个新的对象已经产生了。

但从Java程序的视角来看，对象的创建才刚刚开始，构造函数还没有执行，即`.class`文件中的`<init>()`方法还没执行，当然`new`指令之后会紧接着执行`<init>()`方法的。这时候，从Java程序的视角来看，一个真正可用的对象才算完全被构造出来。



![img](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\10.png)



总的来说，对象创建的过程，就是内存分配的过程。



## 对象的内存布局

首先再次声明，这一部分的讨论对象是==HotSpot虚拟机==。



对象在Java堆中的存储布局可以划分为三个部分：

1. ***对象头（Header）***

   其中对象头中又包括两类信息：

   - *对象自身的运行时数据*，也叫`Mark Word`：

     这部分的数据长度与JVM的位数相同，在32位和64位的JVM中分别为32位和64位。

     由于对象需要存储的运行时数据很多，存储空间又有限，所以Mark Word被设计成一个==有着动态定义的数据结构==。

   - *类型指针*：

     即对象指向它的类型元数据的指针，JVM通过类型指针来确定该对象是哪个类的实例。

     当然并不是所有JVM都有类型指针，因为查找对象的元数据不一定要经过对象本身。

     此外，若对象是一个数组，那么对象头中还得有一块用于记录数组长度的数据。

2. ***实例数据（Instance Data）***

   存储对象真正有效的信息

3. ***对齐填充（Padding）***

   对齐填充不是必然存在的，也没有特别含义，它仅起着==占位符==的作用。

   在HotSpot虚拟机中，对象的大小都是8Byte的整数倍。

   因此，如果对象实例数据部分没有对齐的话，就要通过对齐填充来补全。



![img](D:\blog\source\_drafts\JVM学习之Java内存区域与内存溢出异常\11.png)





## 对象的访问定位

